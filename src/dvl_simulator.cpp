/*@license BSD-3 https://opensource.org/licenses/BSD-3-Clause
Copyright (c) 2024, Institute of Automatic Control - RWTH Aachen University
Maximilian Nitsch (m.nitsch@irt.rwth-aachen.de)
All rights reserved.
*/
#include <iomanip>
#include <iostream>

#include "dvl_simulator.h"

namespace dvl_simulator {

/**
 * @brief Default Constructor of the DvlSimulator class.
 *
 * This constructor initializes the DVL simulator with default parameters.
 * The Janus geometry matrix is calculated given the beam angle DvlSimParams
 * structure.
 *
 * @return An instance of the DvlSimulator class initialized with default
 * parameters. The returned instance is ready for simulation and further
 * configuration.
 */
DvlSimulator::DvlSimulator()
    : constErrorsInitialized_(false),
      altitudeLimitViolated_(false),
      velocityLimitViolated_(false),
      dt_(0.2),
      randomNumberGenerator_(42),
      seed_(42),
      useFixedRandomNumbers_(false),
      normalDistribution_(0, 1),
      uniformDistribution_(0, 1) {

  // Default DVL simulation parameter
  dvlSimParams_.beamVelocityNoiseStdDev = 0.01;    // (m/s)
  dvlSimParams_.intervalInitialScaleFactor = 0.1;  // (%)
  dvlSimParams_.scaleFactorStdDev = 0.0;           // (%/sqrt(s))
  dvlSimParams_.intervalInitialBeamBias =
      Eigen::Vector4d(0.0, 0.0, 0.0, 0.0);  // (m/s)
  dvlSimParams_.biasStdDev = 5e-04;         // (m/s/sqrt(s))
  dvlSimParams_.biasCorrTime = 1800.0;      // (s)
  dvlSimParams_.gyroStdDev =
      Eigen::Vector3d(0.000207479860047933, 0.000243411420514079,
                      0.000187943045943727);              // (rad/s)
  dvlSimParams_.resolution = 1e-04;                       // (m/s)
  dvlSimParams_.beamAngle = 22.5;                         // (deg)
  dvlSimParams_.minAltitude = 0.05;                       // (m)
  dvlSimParams_.maxAltitude = 50.0;                       // (m)
  dvlSimParams_.downDistanceToGround = -5.0;              // (m)
  dvlSimParams_.maxVelocity = 3.75;                       // (m/s)
  dvlSimParams_.p_bs_b = Eigen::Vector3d(0.0, 0.0, 0.0);  // (m)
  dvlSimParams_.C_s_b = Eigen::Matrix3d::Identity();      // (-)

  // Default DVL model enable settings
  dvlModelEnableSettings_.enableBeamVelocityNoise = true;
  dvlModelEnableSettings_.enableScaleFactor = true;
  dvlModelEnableSettings_.enableBeamBias = true;
  dvlModelEnableSettings_.enableGyroNoise = true;
  dvlModelEnableSettings_.enableQuantization = true;
  dvlModelEnableSettings_.enableAltitudeLimit = false;
  dvlModelEnableSettings_.enableVelocityLimit = true;

  // Calculate Janus geometry matrix
  calculateJanusGeometryMatrix();

  // Re-Initialize DVL constant errors
  initializeRandomConstantErrors();
}

/**
 * @brief Constructor of the DvlSimulator class.
 *
 * This constructor initializes the DVL simulator with the given parameters.
 * The Janus geometry matrix is calculated given the beam angle DvlSimParams
 * structure.
 *
 * @param[in] dvlSimParams        The DVL simulation parameters specifying
 * various settings and configurations for the simulator.
 * @param[in] modelEnableSettings The model enable settings determining which
 * simulation models are enabled for computation.
 * @param[in] dt                  The sampling time in seconds (s). It specifies
 * the time interval at which the DVL samples are generated.
 * @param[in] seed                The seed for the random number generator used
 * internally by the simulator to generate stochastic processes.
 *
 * @return An instance of the DvlSimulator class initialized with the provided
 * parameters. The returned instance is ready for simulation and further
 * configuration.
 */
DvlSimulator::DvlSimulator(DvlSimParams dvlSimParams,
                           DvlModelEnableSettings dvlModelEnableSettings,
                           double dt, unsigned int seed)
    : dvlSimParams_(dvlSimParams),
      dvlModelEnableSettings_(dvlModelEnableSettings),
      constErrorsInitialized_(false),
      altitudeLimitViolated_(false),
      velocityLimitViolated_(false),
      dt_(dt),
      randomNumberGenerator_(seed),
      seed_(seed),
      useFixedRandomNumbers_(false),
      normalDistribution_(0, 1),
      uniformDistribution_(0, 1) {

  // Calculate Janus geometry matrix
  calculateJanusGeometryMatrix();

  // Re-Initialize DVL constant errors
  initializeRandomConstantErrors();
}

/**
 * @brief Destructor of the DvlSimulator class.
 *
 * This destructor is responsible for cleaning up the resources used by the DVL
 * simulator.
 *
 * @return None
 */
DvlSimulator::~DvlSimulator() {}

/**
 * @brief Generate a DVL measurement.
 * 
 * This function generates a DVL measurement given the current position, velocity,
 * and angular velocity of the vehicle. The DVL measurement is generated by 
 * transforming the sensor frame velocity to the beam frame velocities and adding
 * white noise, scale factor and bias error to the beam velocities. The least
 * squares sensor frame velocity solution is calculated from the noisy beam
 * velocities. Furthermore, the covariance matrix of the least squares sensor
 * velocity solution is determined. The DVL scale factor random walk model and
 * the DVL beam bias Gauss-Markov model are updated. The DVL velocity
 * measurements are quantized and checked if they are within the working range.
 * If the altitude is not within the working range or the velocity is not within 
 * the working range, the velocity is set to invalid.
 * 
 * @param[in] p_nb_n Position of the vehicle in the navigation frame (m).
 * @param[in] v_nb_b Velocity of the vehicle in the body frame (m/s).
 * @param[in] w_nb_b Angular velocity of the vehicle in the body frame (rad/s).
 * 
 * @return The DVL measurement.
 * 
*/
DvlMeasurement DvlSimulator::generateDvlMeasurement(
    const Eigen::Vector3d& p_nb_n, const Eigen::Vector3d& v_nb_b,
    const Eigen::Vector3d& w_nb_b) {
  // Extract lever arm and rotation matrix
  Eigen::Vector3d p_bs_b = dvlSimParams_.p_bs_b;
  Eigen::Matrix3d C_s_b = dvlSimParams_.C_s_b;

  // Calculate the true DVL sensor frame velocity
  Eigen::Vector3d v_ns_s = C_s_b.transpose() * v_nb_b +
                           calcSkewMatrix3(C_s_b.transpose() * w_nb_b) * p_bs_b;

  // Calculate the true DVL beam velocity
  Eigen::Vector4d v_beam_true = janusGeometryMatrix_.transpose() * v_ns_s;

  // Draw random beam velocity noise (normal distribution)
  Eigen::Vector4d v_DVL_beam = Eigen::Vector4d::Zero();

  if (dvlModelEnableSettings_.enableBeamVelocityNoise) {
    // Draw fixed random numbers for testing/debugging
    if (useFixedRandomNumbers_) {
      v_DVL_beam = dvlSimParams_.beamVelocityNoiseStdDev *
                   Eigen::Vector4d(0.1, 0.2, 0.3, 0.4);
    } else {
      v_DVL_beam =
          dvlSimParams_.beamVelocityNoiseStdDev *
          Eigen::Vector4d(drawRandNormalDistNum(), drawRandNormalDistNum(),
                          drawRandNormalDistNum(), drawRandNormalDistNum());
    }
  }

  // Calculate the measured DVL beam velocity
  Eigen::Vector4d v_beam =
      v_beam_true * (1 + scaleFactor_ / 100) + beamBias_ + v_DVL_beam;

  // Calculate least squares sensor frame velocity solution
  v_ns_s = janusGeometryMatrixPInv_ * v_beam;

  // Extract gyroscope white noise and discretize
  Eigen::Matrix3d Qw = Eigen::Matrix3d::Zero();

  if (dvlModelEnableSettings_.enableGyroNoise) {
    Qw(0, 0) = dvlSimParams_.gyroStdDev(0) * dvlSimParams_.gyroStdDev(0) / dt_;
    Qw(1, 1) = dvlSimParams_.gyroStdDev(1) * dvlSimParams_.gyroStdDev(1) / dt_;
    Qw(2, 2) = dvlSimParams_.gyroStdDev(2) * dvlSimParams_.gyroStdDev(2) / dt_;
  }

  // Calculate covariance matrix of least squares sensor frame velocity solution
  Eigen::Matrix3d R_DVL = Eigen::Matrix3d::Zero();
  R_DVL = janusGeometryMatrixPInv_ * dvlSimParams_.beamVelocityNoiseStdDev *
              dvlSimParams_.beamVelocityNoiseStdDev *
              janusGeometryMatrixPInv_.transpose() +
          calcSkewMatrix3(dvlSimParams_.p_bs_b) * Qw *
              calcSkewMatrix3(dvlSimParams_.p_bs_b).transpose();

  // Update DVL scale factor random walk model
  if (dvlModelEnableSettings_.enableScaleFactor) {
    updateScaleFactorRandomWalkModel();
  }

  // Update DVL beam bias Gauss-Markov model
  if (dvlModelEnableSettings_.enableBeamBias) {
    updateBeamBiasGaussMarkovModel();
  }

  // Quantize DVL velocity measurements
  if (dvlModelEnableSettings_.enableQuantization) {
    v_ns_s = calcQuantizationModel(v_ns_s, dvlSimParams_.resolution);
  }

  double altitude = p_nb_n(2) - dvlSimParams_.downDistanceToGround;

  // Set validity flags
  bool velocityValid = true;
  altitudeLimitViolated_ = false;
  velocityLimitViolated_ = false;

  // Check if altitude is within working range
  if ((altitude < dvlSimParams_.minAltitude ||
       altitude > dvlSimParams_.maxAltitude) &&
      dvlModelEnableSettings_.enableAltitudeLimit) {
    velocityValid = false;
    altitudeLimitViolated_ = true;
  }

  // Check if velocity is within working range
  if ((v_ns_s.norm() > dvlSimParams_.maxVelocity) &&
      dvlModelEnableSettings_.enableVelocityLimit) {
    velocityValid = false;
    velocityLimitViolated_ = true;
  }

  // Fill DVL measurement structure
  DvlMeasurement dvlMeasurement;
  dvlMeasurement.velocity = v_ns_s;
  dvlMeasurement.covariance = R_DVL;
  dvlMeasurement.beamVelocities = v_beam;
  dvlMeasurement.velocityValid = velocityValid;

  return dvlMeasurement;
}

/**
 * @brief Reset the DVL simulator.
 * 
 * This function resets the DVL simulator by re-initializing the DVL constant 
 * errors.
 * 
 * @return None
*/
void DvlSimulator::resetSimulator() {
  // Reset flag indicating if DVL constant errors are initialized
  constErrorsInitialized_ = false;

  // Reset flags indicating if limits are violated
  altitudeLimitViolated_ = false;
  velocityLimitViolated_ = false;

  // Re-Initialize DVL constant errors
  initializeRandomConstantErrors();
}

/**
 * @brief Get the DVL simulation parameters.
 * 
 * This function returns the DVL simulation parameters used by the DVL simulator.
 * 
 * @return The DVL simulation parameters.
*/
DvlSimParams DvlSimulator::getDvlSimParams() const {
  return dvlSimParams_;
}

/**
 * @brief Get the DVL scale factor.
 * 
 * This function returns the DVL scale factor used by the DVL simulator.
 * 
 * @return The DVL scale factor.
*/
double DvlSimulator::getScaleFactor() const {
  return scaleFactor_;
}

/**
 * @brief Get the beam bias.
 * 
 * This function returns the beam bias used by the DVL simulator.
 * 
 * @return The beam bias.
*/
Eigen::Vector4d DvlSimulator::getBeamBias() const {
  return beamBias_;
}

/**
 * @brief Get the Janus geometry matrix.
 * 
 * This function returns the Janus geometry matrix used to transform the sensor
 * frame velocity to the beam frame velocities.
 * 
 * @return The Janus geometry matrix.
*/
Eigen::Matrix<double, 3, 4> DvlSimulator::getJanusGeometryMatrix() const {
  return janusGeometryMatrix_;
}

/**
 * @brief Get the pseudoinverse of the Janus geometry matrix.
 * 
 * This function returns the pseudoinverse of the Janus geometry matrix used to
 * transform the beam velocities to the sensor frame velocity.
 * 
 * @return The pseudoinverse of the Janus geometry matrix.
*/
Eigen::Matrix<double, 3, 4> DvlSimulator::getJanusGeometryMatrixPInv() const {
  return janusGeometryMatrixPInv_;
}

/**
 * @brief Set the model enable settings.
 *
 * This function sets the model enable settings used by the DVL simulator.
 *
 * @param[in] modelEnableSettings The model enable settings.
 *
 * @return None
 */
DvlModelEnableSettings DvlSimulator::getDvlModelEnableSettings() const {
  return dvlModelEnableSettings_;
}

/**
 * @brief Get the flag indicating if the altitude limit is violated.
 *
 * This function returns the flag indicating if the altitude limit is violated.
 *
 * @return The flag indicating if the altitude limit is violated.
 */
bool DvlSimulator::getAltitudeLimitViolated() const {
  return altitudeLimitViolated_;
}

/**
 * @brief Get the flag indicating if the velocity limit is violated.
 *
 * This function returns the flag indicating if the velocity limit is violated.
 *
 * @return The flag indicating if the velocity limit is violated.
 */
bool DvlSimulator::getVelocityLimitViolated() const {
  return velocityLimitViolated_;
}

/**
 * @brief Get the DVL sample time.
 *
 * This function returns the sample time used by the DVL simulator.
 *
 * @return The sample time in seconds (s).
 */
double DvlSimulator::getSampleTime() const {
  return dt_;
}

/**
 * @brief Get the seed of the random number generator.
 *
 * This function returns the seed of the random number generator used by the DVL
 * simulator.
 *
 * @return The seed of the random number generator.
 */
unsigned int DvlSimulator::getSeed() const {
  return seed_;
}

/**
 * @brief Get the flag indicating if fixed random numbers are used in stochastic
 * error models.
 *
 * This function returns the flag indicating if fixed random numbers are used in
 * the stochastic error models.
 *
 * @return The flag indicating if fixed random numbers are used.
 */
bool DvlSimulator::getUseFixedRandomNumbers() const {
  return useFixedRandomNumbers_;
}

/**
 * @brief Set the DVL simulation parameters.
 *
 * This function sets the DVL simulation parameters used by the DVL simulator.
 *
 * @param[in] dvlSimParams The DVL simulation parameters.
 *
 * @return None
 */
void DvlSimulator::setDvlSimParams(const DvlSimParams& dvlSimParams) {
  dvlSimParams_ = dvlSimParams;
}

/**
 * @brief Set the DVL model enable settings.
 *
 * This function sets the DVL model enable settings used by the DVL simulator.
 *
 * @param[in] dvlModelEnableSettings The DVL model enable settings.
 *
 * @return None
 */
void DvlSimulator::setDvlModelEnableSettings(
    const DvlModelEnableSettings& dvlModelEnableSettings) {
  dvlModelEnableSettings_ = dvlModelEnableSettings;
}

/**
 * @brief Set the flag indicating if beam velocity noise model is enabled.
 *
 * This function sets the flag indicating if the beam velocity noise model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the beam velocity noise model is
 * enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableBeamVelocityNoise(
    const bool enableBeamVelocityNoise) {
  dvlModelEnableSettings_.enableBeamVelocityNoise = enableBeamVelocityNoise;
}

/**
 * @brief Set the flag indicating if scale factor model is enabled.
 *
 * This function sets the flag indicating if the scale factor model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the scale factor model is
 * enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableScaleFactor(const bool enableScaleFactor) {
  dvlModelEnableSettings_.enableScaleFactor = enableScaleFactor;
}

/**
 * @brief Set the flag indicating if beam bias model is enabled.
 *
 * This function sets the flag indicating if the beam bias model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the beam bias model is
 * enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableBeamBias(const bool enableBeamBias) {
  dvlModelEnableSettings_.enableBeamBias = enableBeamBias;
}

/**
 * @brief Set the flag indicating if gyroscope noise model is enabled.
 *
 * This function sets the flag indicating if the gyroscope noise model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the gyroscope noise model is
 * enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableGyroNoise(const bool enableGyroNoise) {
  dvlModelEnableSettings_.enableGyroNoise = enableGyroNoise;
}

/**
 * @brief Set the flag indicating if quantization model is enabled.
 *
 * This function sets the flag indicating if quantization model is enabled.
 *
 * @param[in] enable The flag indicating if quantization model is enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableQuantization(const bool enableQuantization) {
  dvlModelEnableSettings_.enableQuantization = enableQuantization;
}

/**
 * @brief Set the flag indicating if altitude limit model is enabled.
 *
 * This function sets the flag indicating if altitude limit model is enabled.
 *
 * @param[in] enable The flag indicating if altitude limit model is enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableAltitudeLimit(const bool enableAltitudeLimit) {
  dvlModelEnableSettings_.enableAltitudeLimit = enableAltitudeLimit;
}

/**
 * @brief Set the flag indicating if velocity limit model is enabled.
 *
 * This function sets the flag indicating if velocity limit model is enabled.
 *
 * @param[in] enable The flag indicating if velocity limit model is enabled.
 *
 * @return None
 */
void DvlSimulator::setEnableVelocityLimit(const bool enableVelocityLimit) {
  dvlModelEnableSettings_.enableVelocityLimit = enableVelocityLimit;
}

/**
 * @brief Set the DVL sample time.
 *
 * This function sets the sample time used by the DVL simulator.
 *
 * @param[in] dt The sample time in seconds (s).
 *
 * @return None
 */
void DvlSimulator::setSampleTime(const double dt) {
  dt_ = dt;
}

/**
 * @brief Set the seed of the random number generator.
 *
 * This function sets the seed of the random number generator used by the DVL
 * simulator.
 *
 * @param[in] seed The seed of the random number generator.
 *
 * @return None
 */
void DvlSimulator::setSeed(const unsigned int seed) {
  randomNumberGenerator_.seed(seed);
  seed_ = seed;
}

/**
 * @brief Set the flag indicating if fixed random numbers are used in stochastic
 * error model.
 *
 * This function sets the flag indicating if fixed random numbers are used in
 * the stochastic error model.
 *
 * @param[in] enable The flag indicating if fixed random numbers are used.
 *
 * @return None
 */
void DvlSimulator::setUseFixedRandomNumbers(const bool useFixedRandomNumbers) {
  useFixedRandomNumbers_ = useFixedRandomNumbers;
}

/**
 * @brief Print the DVL simulator parameters.
 *
 * This function prints the DVL simulator parameters to the standard output.
 *
 * @return A stringstream containing the DVL simulator parameters.
 */
std::stringstream DvlSimulator::printDvlSimulatorParameters() {
  // Create stringstream to store the output
  std::stringstream ss;

  ss << "***************************************************************"
        "********************************************************************"
        "**"
        "*"
     << "\n";
  ss << std::left << std::setw(50) << "Starting DVL Simulator"
     << "\n";
  ss << "***************************************************************"
        "********************************************************************"
        "**"
        "*"
     << "\n";

  // DVL simulation parameters
  ss << std::left << "Simulation parameters:\n";

  ss << std::fixed << std::setprecision(6);

  ss << std::left << std::setw(50)
     << "beamVelocityNoiseStdDev:" << dvlSimParams_.beamVelocityNoiseStdDev
     << " m/s\n";

  ss << std::left << std::setw(50) << "intervalInitialScaleFactor:"
     << dvlSimParams_.intervalInitialScaleFactor << " %\n";

  ss << std::left << std::setw(50)
     << "scaleFactorStdDev:" << dvlSimParams_.scaleFactorStdDev
     << " %/sqrt(s)\n";

  ss << std::left << std::setw(50) << "intervalInitialBeamBias:"
     << dvlSimParams_.intervalInitialBeamBias.transpose() << " m/s\n";

  ss << std::left << std::setw(50) << "biasStdDev:" << dvlSimParams_.biasStdDev
     << " m/s/sqrt(s)\n";

  ss << std::left << std::setw(50)
     << "biasCorrTime:" << dvlSimParams_.biasCorrTime << " s\n";

  ss << std::left << std::setw(50)
     << "gyroStdDev:" << dvlSimParams_.gyroStdDev.transpose() << " rad/s\n";

  ss << std::left << std::setw(50) << "resolution:" << dvlSimParams_.resolution
     << " m/s\n";

  ss << std::left << std::setw(50) << "beamAngle:" << dvlSimParams_.beamAngle
     << " deg\n";

  ss << std::left << std::setw(50)
     << "minAltitude:" << dvlSimParams_.minAltitude << " m\n";

  ss << std::left << std::setw(50)
     << "maxAltitude:" << dvlSimParams_.maxAltitude << " m\n";

  ss << std::left << std::setw(50)
     << "downDistanceToGround:" << dvlSimParams_.downDistanceToGround << " m\n";

  ss << std::left << std::setw(50)
     << "maxVelocity:" << dvlSimParams_.maxVelocity << " m/s\n";

  ss << std::left << std::setw(50)
     << "p_bs_b:" << dvlSimParams_.p_bs_b.transpose() << " m\n";

  ss << std::left << std::setw(50) << "C_s_b as RPY angle:"
     << dvlSimParams_.C_s_b.eulerAngles(2, 1, 0).transpose() * 180 / M_PI
     << " deg\n";

  ss << "***************************************************************"
        "********************************************************************"
        "**"
        "*"
     << "\n";

  // DVL model enable settings
  ss << std::left << "Model enable settings:\n";

  ss << std::left << std::setw(50) << "Beam velocity noise:"
     << dvlModelEnableSettings_.enableBeamVelocityNoise << "\n";

  ss << std::left << std::setw(50)
     << "Scale factor:" << dvlModelEnableSettings_.enableScaleFactor << "\n";

  ss << std::left << std::setw(50)
     << "Beam bias:" << dvlModelEnableSettings_.enableBeamBias << "\n";

  ss << std::left << std::setw(50)
     << "Gyroscope noise:" << dvlModelEnableSettings_.enableGyroNoise << "\n";

  ss << std::left << std::setw(50)
     << "Quantization:" << dvlModelEnableSettings_.enableQuantization << "\n";

  ss << std::left << std::setw(50)
     << "Altitude limit:" << dvlModelEnableSettings_.enableAltitudeLimit
     << "\n";

  ss << std::left << std::setw(50)
     << "Velocity limit:" << dvlModelEnableSettings_.enableVelocityLimit
     << "\n";

  ss << "\n";

  // Sampling time and frequency
  ss << std::left << std::setw(50) << "Sampling time:" << std::fixed
     << std::setprecision(6) << dt_ << " s\n";

  ss << std::left << std::setw(50) << "Sampling frequency:" << std::fixed
     << std::setprecision(6) << 1.0 / dt_ << " Hz\n";

  ss << "***************************************************************"
        "********************************************************************"
        "**"
        "*"
     << "\n";

  return ss;
}

/**
 * @brief Calculate the Janus geometry matrix.
 * 
 * This function calculates the Janus geometry matrix given the beam angle
 * DvlSimParams structure. The Janus geometry matrix is used to transform the
 * sensor frame velocity to the beam frame velocity and vice versa.
 * 
 * @return None
*/
void DvlSimulator::calculateJanusGeometryMatrix() {
  // Define Janus geometry matrix
  janusGeometryMatrix_ = Eigen::Matrix<double, 3, 4>::Zero();

  // Define angles between the beams
  double psi1 = 45 * M_PI / 180;
  double psi2 = 135 * M_PI / 180;
  double psi3 = 225 * M_PI / 180;
  double psi4 = 315 * M_PI / 180;

  // Define Janus beam angles
  double theta1 = dvlSimParams_.beamAngle * M_PI / 180;
  double theta2 = dvlSimParams_.beamAngle * M_PI / 180;
  double theta3 = dvlSimParams_.beamAngle * M_PI / 180;
  double theta4 = dvlSimParams_.beamAngle * M_PI / 180;

  // Precompute trigonometric functions
  double sPsi1 = std::sin(psi1);
  double sPsi2 = std::sin(psi2);
  double sPsi3 = std::sin(psi3);
  double sPsi4 = std::sin(psi4);

  double cPsi1 = std::cos(psi1);
  double cPsi2 = std::cos(psi2);
  double cPsi3 = std::cos(psi3);
  double cPsi4 = std::cos(psi4);

  double sTheta1 = std::sin(theta1);
  double sTheta2 = std::sin(theta2);
  double sTheta3 = std::sin(theta3);
  double sTheta4 = std::sin(theta4);

  double cTheta1 = std::cos(theta1);
  double cTheta2 = std::cos(theta2);
  double cTheta3 = std::cos(theta3);
  double cTheta4 = std::cos(theta4);

  // Calculate Janus geometry matrix
  janusGeometryMatrix_ << cPsi1 * sTheta1, cPsi2 * sTheta2, cPsi3 * sTheta3,
      cPsi4 * sTheta4, sPsi1 * sTheta1, sPsi2 * sTheta2, sPsi3 * sTheta3,
      sPsi4 * sTheta4, cTheta1, cTheta2, cTheta3, cTheta4;

  // Compute the pseudoinverse of the Janus geometry matrix
  Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<double, 3, 4>>
      completeOrthogonalDecomposition(janusGeometryMatrix_);

  janusGeometryMatrixPInv_ =
      completeOrthogonalDecomposition.pseudoInverse().transpose();
}

/**
 * @brief Update the DVL scale factor random walk model.
 * 
 * This function updates the DVL scale factor random walk model by propagating
 * the scale factor with a random walk model. The scale factor is updated by
 * adding a normal distributed noise to the scale factor.
 * 
 * @return None
*/
void DvlSimulator::updateScaleFactorRandomWalkModel() {
  // Define noise vector
  double v_scale_factor;

  if (useFixedRandomNumbers_) {
    // Set constant scale factor noise for testing/debugging
    v_scale_factor = 0.5 * dvlSimParams_.scaleFactorStdDev * std::sqrt(dt_);
  } else {
    // Draw normal distributed scale factor noise
    v_scale_factor = drawRandNormalDistNum() * dvlSimParams_.scaleFactorStdDev *
                     std::sqrt(dt_);
  }
  // Propagate DVL scale factor random walk model

  scaleFactor_ = scaleFactor_ + v_scale_factor;
}

/**
 * @brief Update the DVL beam bias Gauss-Markov model.
 * 
 * This function updates the DVL beam bias Gauss-Markov model by propagating the
 * beam bias with a Gauss-Markov model. The beam bias is updated by adding a
 * normal distributed noise to the beam bias.
 * 
 * @return None
*/
void DvlSimulator::updateBeamBiasGaussMarkovModel() {
  // Create discrete noise covariance matrix
  double Q_k = dvlSimParams_.biasStdDev * dvlSimParams_.biasStdDev *
               (1 - std::exp(-2 * dt_ / dvlSimParams_.biasCorrTime));

  double beamBiasStdDev = std::sqrt(Q_k);

  // Define noise vector
  Eigen::Vector4d v_beam_bias;

  if (useFixedRandomNumbers_) {
    // Set constant beam bias noise for testing/debugging
    v_beam_bias = beamBiasStdDev * Eigen::Vector4d(0.6, 0.7, 0.8, 0.9);
  } else {
    // Draw normal distributed beam bias noise for each transducer
    v_beam_bias = beamBiasStdDev * Eigen::Vector4d(drawRandNormalDistNum(),
                                                   drawRandNormalDistNum(),
                                                   drawRandNormalDistNum(),
                                                   drawRandNormalDistNum());
  }
  // Propagate DVL beam bias Gauss-Markov model
  beamBias_ =
      beamBias_ * std::exp(-dt_ / dvlSimParams_.biasCorrTime) + v_beam_bias;
}

/**
 * @brief Quantization model for DVL velocity measurements.
 * 
 * This function quantizes the measurement vector to the resolution of the resolution vector.
 * This replicates that an DVL can only measure values with a certain resolution (Analog/Digital conversion).
 * 
 * @param measurement Vector of DVL measurements.
 * @param resolution Resolution of the DVL measurements.
 * 
 * @return Quantized measurement vector.
*/
Eigen::Vector3d DvlSimulator::calcQuantizationModel(
    const Eigen::Vector3d& measurement, const double resolution) {
  // Quantized measurement vector
  Eigen::Vector3d quantizedMeasurement;

  // Quantize elements of measurement to resolution
  quantizedMeasurement(0) =
      std::round(measurement(0) / resolution) * resolution;
  quantizedMeasurement(1) =
      std::round(measurement(1) / resolution) * resolution;
  quantizedMeasurement(2) =
      std::round(measurement(2) / resolution) * resolution;

  return quantizedMeasurement;
}

/**
 * @brief Calculate the skew matrix of a given vector.
 * 
 * This function calculates the skew matrix of a given vector which is defined as:
 * \f[
 * \mathbf{V} = \begin{bmatrix}
 * 0 & -v_3 & v_2 \\
 * v_3 & 0 & -v_1 \\
 * -v_2 & v_1 & 0
 * \end{bmatrix}
 * \f]
 * 
 * @param v Vector.
 * @return 3x3 skew matrix of the given vector.
*/
Eigen::Matrix3d DvlSimulator::calcSkewMatrix3(const Eigen::Vector3d& v) {
  Eigen::Matrix3d V;
  V << 0.0, -v(2), v(1), v(2), 0, -v(0), -v(1), v(0), 0.0;
  return V;
}

/**
 * @brief Initializes the DVL constant errors.
 * 
 * This function initializes the DVL constant errors by drawing random numbers from a uniform distribution.
 * The following DVL constant errors are initialized:
 * - scale factor,
 * - beam bias.
*/
void DvlSimulator::initializeRandomConstantErrors() {
  // Draw random numbers for constant errors
  if (useFixedRandomNumbers_) {
    // Set constant scale factor for testing/debugging
    scaleFactor_ = 1.25;

    // Set contant beam bias for each transducer for testing/debugging
    beamBias_(0) = 0.25;
    beamBias_(1) = 0.50;
    beamBias_(2) = 0.75;
    beamBias_(3) = 1.00;

  } else {
    // Draw uniform distributed scale factor
    scaleFactor_ = drawRandUniformDistNumFromInterval(
        dvlSimParams_.intervalInitialScaleFactor);

    // Draw uniform distributed beam bias for each transducer
    beamBias_(0) = drawRandUniformDistNumFromInterval(
        dvlSimParams_.intervalInitialBeamBias(0));
    beamBias_(1) = drawRandUniformDistNumFromInterval(
        dvlSimParams_.intervalInitialBeamBias(1));
    beamBias_(2) = drawRandUniformDistNumFromInterval(
        dvlSimParams_.intervalInitialBeamBias(2));
    beamBias_(3) = drawRandUniformDistNumFromInterval(
        dvlSimParams_.intervalInitialBeamBias(3));
  }

  // Set flag indicating that constant errors are initialized
  constErrorsInitialized_ = true;
}

/**
 * @brief Draws a random number from a normal distribution.
 * 
 * This function draws a random number from a normal distribution with the given mean and standard deviation.
 * 
 * @return Single random number from the normal distribution.
*/
double DvlSimulator::drawRandNormalDistNum() {
  // Generate normal distributed random number
  return normalDistribution_(randomNumberGenerator_);
}

/**
 * @brief Draws a random number from a uniform distribution.
 * 
 * This function draws a random number from a uniform distribution in a given interval [-interval, +interval].
 * 
 * @param interval Interval of the uniform distribution.
 * @return Single random number from the uniform distribution.
*/
double DvlSimulator::drawRandUniformDistNumFromInterval(const double interval) {
  // Generate uniform distributed random number
  double randUniformNum = uniformDistribution_(randomNumberGenerator_);

  double a = -interval;
  double b = interval;

  return (b - a) * randUniformNum + a;
}

}  // namespace dvl_simulator
